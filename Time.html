<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Time</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #1a1a1a;
        font-family: "Courier New", monospace;
        color: #0f0;
        overflow: hidden;
      }
      #clock {
        font-size: 6rem;
        text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        font-variant-numeric: tabular-nums;
        cursor: default;
      }
      #zone-display {
        font-size: 1.2rem;
        margin-bottom: 5px;
        color: #888;
        font-weight: bold;
      }
      #status {
        margin-top: 10px;
        font-size: 0.8rem;
        color: #555;
        opacity: 0;
        transition: opacity 1s ease;
      }
    </style>
  </head>
  <body>
    <div id="zone-display">Detecting Zone...</div>
    <div id="clock">00:00:00</div>
    <div id="status">Syncing precision...</div>

    <script>
      // --- Configuration ---
      // AUTOMATICALLY DETECT USER'S DEVICE TIMEZONE (IANA format, e.g., "America/New_York")
      const USER_ZONE = Intl.DateTimeFormat().resolvedOptions().timeZone;

      const CLOCK_EL = document.getElementById("clock");
      const STATUS_EL = document.getElementById("status");
      const ZONE_EL = document.getElementById("zone-display");

      // Update UI to show which zone was detected
      ZONE_EL.textContent = USER_ZONE;

      // 1. Formatter using the detected zone
      const timeFormatter = new Intl.DateTimeFormat("en-GB", {
        timeZone: USER_ZONE,
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      });

      // 2. State: 'skew' is the difference between server time and local time
      let timeSkew = 0;

      // --- Core Clock Logic ---
      function tick() {
        // Calculate current time: Local System Time + Network Correction
        const now = new Date(Date.now() + timeSkew);
        CLOCK_EL.textContent = timeFormatter.format(now);

        // Schedule next tick specifically at the start of the next second
        const msUntilNextSecond = 1000 - now.getMilliseconds();
        setTimeout(tick, msUntilNextSecond);
      }

      // Start immediately
      tick();

      // --- Network Sync Logic ---
      const syncTime = async () => {
        const controller = new AbortController();
        const signal = controller.signal;

        const get = (url, parseFn) =>
          fetch(url, { signal, mode: "cors" })
            .then((res) => (res.ok ? res.json() : Promise.reject()))
            .then((data) => parseFn(data));

        const nowTs = Date.now();

        try {
          // We pass the detected USER_ZONE to the APIs to get the precise atomic time for that specific location
          const serverDate = await Promise.any([
            get(
              `https://timeapi.io/api/Time/current/zone?timeZone=${USER_ZONE}`,
              (d) => new Date(d.dateTime),
            ),
            get(
              `https://worldtimeapi.org/api/timezone/${USER_ZONE}`,
              (d) => new Date(d.datetime),
            ),
            // Backup: If specific zone fails, try IP-based geolocation
            get(`https://worldtimeapi.org/api/ip`, (d) => new Date(d.datetime)),
          ]);

          const latency = (Date.now() - nowTs) / 2;
          const preciseTime = serverDate.getTime() + latency;

          // Update global skew
          timeSkew = preciseTime - Date.now();

          STATUS_EL.textContent = `Synced: Precision Â±${Math.round(latency)}ms`;
          STATUS_EL.style.opacity = 1;
          controller.abort();
        } catch (e) {
          // If APIs fail (e.g. offline), we just rely on the system clock (skew remains 0)
          STATUS_EL.textContent = "Sync failed. Using device system time.";
          STATUS_EL.style.opacity = 1;
        }
      };

      // Trigger sync
      syncTime();
    </script>
  </body>
</html>
