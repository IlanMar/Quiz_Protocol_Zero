<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tel Aviv Clock - Optimized</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #1a1a1a;
        font-family: "Courier New", monospace;
        color: #0f0;
        overflow: hidden; /* Prevents scrollbars */
      }
      #clock {
        font-size: 6rem; /* Large and clear */
        text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        font-variant-numeric: tabular-nums; /* Prevents jitter when numbers change */
        cursor: default;
      }
      #status {
        margin-top: 10px;
        font-size: 0.8rem;
        color: #555;
        opacity: 0; /* Hidden by default, fades in on sync */
        transition: opacity 1s ease;
      }
    </style>
  </head>
  <body>
    <div id="clock">00:00:00</div>
    <div id="status">Syncing precision...</div>

    <script>
      // --- Configuration ---
      const TARGET_ZONE = "Asia/Jerusalem";
      const CLOCK_EL = document.getElementById("clock");
      const STATUS_EL = document.getElementById("status");

      // 1. Pre-calculate formatter (Major performance boost over toLocaleTimeString)
      const timeFormatter = new Intl.DateTimeFormat("en-GB", {
        timeZone: TARGET_ZONE,
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      });

      // 2. State: 'skew' is the difference between server time and local time
      let timeSkew = 0;

      // --- Core Clock Logic ---
      function tick() {
        // Calculate current time: Local System Time + Network Correction
        const now = new Date(Date.now() + timeSkew);
        CLOCK_EL.textContent = timeFormatter.format(now);

        // Schedule next tick specifically at the start of the next second
        // This is much more efficient than a blind setInterval(1000)
        const msUntilNextSecond = 1000 - now.getMilliseconds();
        setTimeout(tick, msUntilNextSecond);
      }

      // Start immediately with local time (0ms latency perception)
      tick();

      // --- Network Sync Logic ---
      const syncTime = async () => {
        const controller = new AbortController();
        const signal = controller.signal;

        // Minified Fetch Wrapper
        const get = (url, parseFn) =>
          fetch(url, { signal, mode: "cors" })
            .then((res) => (res.ok ? res.json() : Promise.reject()))
            .then((data) => parseFn(data));

        const nowTs = Date.now();

        // Race Sources
        try {
          const serverDate = await Promise.any([
            get(
              `https://timeapi.io/api/Time/current/zone?timeZone=${TARGET_ZONE}`,
              (d) => new Date(d.dateTime),
            ),
            get(
              `https://worldtimeapi.org/api/timezone/${TARGET_ZONE}`,
              (d) => new Date(d.datetime),
            ),
            // Added a 3rd robust source just in case
            get(
              `https://api.in-adi.com/time?timezone=${TARGET_ZONE}`,
              (d) => new Date(d.datetime),
            ),
          ]);

          // Calculate latency compensation (approximate) and skew
          const latency = (Date.now() - nowTs) / 2;
          const preciseTime = serverDate.getTime() + latency;

          // Update global skew
          timeSkew = preciseTime - Date.now();

          // Update UI status
          STATUS_EL.textContent = `Synced: Precision Â±${Math.round(latency)}ms`;
          STATUS_EL.style.opacity = 1;
          controller.abort(); // Cancel losing requests to save bandwidth
        } catch (e) {
          STATUS_EL.textContent = "Sync failed. Using local time.";
          STATUS_EL.style.opacity = 1;
        }
      };

      // Trigger sync
      syncTime();
    </script>
  </body>
</html>
