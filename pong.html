<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Новогодний Понг 2026</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #99b998; /* Nokia LCD green */
        font-family: "VT323", monospace;
        touch-action: none;
        color: #000;
      }

      canvas {
        display: block;
        image-rendering: pixelated;
      }

      #ui {
        position: absolute;
        top: 20px;
        width: 100%;
        text-align: center;
        color: #000;
        font-size: 32px;
        font-weight: bold;
        pointer-events: none;
        user-select: none;
        z-index: 10;
      }

      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(153, 185, 152, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #000;
        z-index: 20;
        text-align: center;
      }

      .btn {
        padding: 10px 25px;
        font-size: 24px;
        background: #000;
        color: #99b998;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 20px;
        font-family: "VT323", monospace;
        box-shadow: 0 4px 0 #333;
      }

      .btn:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #333;
      }

      /* Scanline effect */
      .scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.05) 50%,
          rgba(0, 0, 0, 0.05)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 15;
      }

      /* Snow effect from snake.html */
      .snowflake {
        position: absolute;
        top: -20px;
        color: #000;
        font-size: 1em;
        opacity: 0.2;
        pointer-events: none;
        animation: fall linear infinite;
        z-index: 5;
      }

      @keyframes fall {
        to {
          transform: translateY(105vh);
        }
      }

      /* Milestone congratulations overlay */
      #milestone-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(153, 185, 152, 0.95);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #000;
        z-index: 25;
        text-align: center;
        padding: 24px;
        box-sizing: border-box;
        pointer-events: auto;
        user-select: none;
      }

      #milestone-title {
        font-size: 44px;
        margin: 0 0 8px 0;
      }

      #milestone-text {
        font-size: 28px;
        max-width: 820px;
        line-height: 1.1;
        margin: 0;
      }

      #milestone-hint {
        font-size: 22px;
        opacity: 0.8;
        margin-top: 12px;
      }
    </style>
  </head>
  <body>
    <div class="scanlines"></div>
    <div id="ui">
      <span id="playerScore">0</span> : <span id="aiScore">0</span>
    </div>

    <div id="milestone-screen" role="dialog" aria-modal="true">
      <h2 id="milestone-title">С наступающим!</h2>
      <p id="milestone-text"></p>
      <div id="milestone-hint">Нажми «Продолжить», чтобы вернуться в матч.</div>
      <button class="btn" id="milestone-continue" type="button">
        Продолжить
      </button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const playerScoreEl = document.getElementById("playerScore");
      const aiScoreEl = document.getElementById("aiScore");

      const milestoneScreen = document.getElementById("milestone-screen");
      const milestoneTextEl = document.getElementById("milestone-text");
      const milestoneContinueBtn =
        document.getElementById("milestone-continue");

      let gameRunning = false;
      let audioCtx = null;

      const milestoneMessages = [
        "5:0 — это не счёт, это релиз без багов. С наступающим!",
        "Ты так уверенно отбиваешь, что даже баги боятся подходить к продакшену. С праздником!",
        "Новогодний патч: +5 к скиллу, −100 к надеждам ИИ на победу. Продолжай!",
        "Похоже, твой пинг — 0, а у соперника — ‘временная петля’. С наступающим!",
        "Этот мячик уже готов подписать NDA и перейти на твою сторону. С праздником!",
        "Если бы дед Мороз видел твой тайминг, он бы попросил тебя настроить куранты. С наступающим!",
        "Поздравляем! Ты только что провёл аудит соперника: несоответствий — ровно 5.",
        "Твой удар настолько точный, что QR‑коды сами сканируются. С праздником!",
        "Тонкий намёк: иногда правильнее ‘перезагрузить’, чем спорить с экраном. С наступающим!",
        "5 голов — и ни одного синего экрана. Это уже корпоративное чудо. С праздником!",
      ];

      let milestoneDeck = [];
      let nextPlayerMilestone = 5;

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function getNextMilestoneMessage() {
        if (milestoneDeck.length === 0) {
          milestoneDeck = shuffleInPlace([...milestoneMessages]);
        }
        return milestoneDeck.pop();
      }

      function showMilestoneMessage(message) {
        milestoneTextEl.textContent = message;
        milestoneScreen.style.display = "flex";
        gameRunning = false;
      }

      function hideMilestoneMessage() {
        if (milestoneScreen.style.display !== "flex") return;
        milestoneScreen.style.display = "none";
        gameRunning = true;
      }

      function playSound(frequency, duration) {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.type = "square";
        oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioCtx.currentTime + duration
        );

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.start();
        oscillator.stop(audioCtx.currentTime + duration);
      }

      // Game constants
      const PADDLE_WIDTH = 16;
      const PADDLE_HEIGHT = 110;
      const BALL_SIZE = 12;
      const INITIAL_BALL_SPEED = 5;
      const SPEED_INCREMENT = 0.2;

      // Game state
      let player = { x: 20, y: 0, score: 0, color: "#000000" };
      let ai = { x: 0, y: 0, score: 0, color: "#000000" };
      let ball = { x: 0, y: 0, dx: 0, dy: 0, color: "#000000" };
      const NUM_OBSTACLES = 3;
      let obstacles = [];

      function init() {
        resize();
        player.y = canvas.height / 2 - PADDLE_HEIGHT / 2;
        ai.x = canvas.width - PADDLE_WIDTH - 20;
        ai.y = canvas.height / 2 - PADDLE_HEIGHT / 2;
        setInterval(createSnow, 300);

        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }
        gameRunning = true;
        player.score = 0;
        ai.score = 0;
        nextPlayerMilestone = 5;
        milestoneDeck = [];
        milestoneScreen.style.display = "none";
        playerScoreEl.innerText = "0";
        aiScoreEl.innerText = "0";
        resetBall();
        resetObstacles();
      }

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ai.x = canvas.width - PADDLE_WIDTH - 20;
      }

      // Snow effect from snake.html
      function createSnow() {
        const snow = document.createElement("div");
        snow.innerHTML = "❄";
        snow.className = "snowflake";
        snow.style.left = Math.random() * 100 + "vw";
        snow.style.animationDuration = Math.random() * 3 + 2 + "s";
        snow.style.fontSize = Math.random() * 10 + 10 + "px";
        document.body.appendChild(snow);

        setTimeout(() => {
          snow.remove();
        }, 5000);
      }

      function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        const angle = ((Math.random() - 0.5) * Math.PI) / 2; // Random angle between -45 and 45 deg
        const direction = 1; // Always towards AI
        ball.dx = direction * INITIAL_BALL_SPEED * Math.cos(angle);
        ball.dy = INITIAL_BALL_SPEED * Math.sin(angle);
      }

      function resetObstacles() {
        obstacles = [];
        const radius = 32; // уменьшено примерно в 2 раза
        const speed = 2.5;
        for (let i = 0; i < NUM_OBSTACLES; i++) {
          // spread obstacles horizontally around center
          const xOffset =
            (i - Math.floor(NUM_OBSTACLES / 2)) * (radius * 2 + 40);
          const x = canvas.width / 2 + xOffset;
          let y = Math.random() * (canvas.height - radius * 2) + radius;

          // Ensure it's not too close to the center where the ball starts
          if (Math.abs(y - canvas.height / 2) < radius + 50) {
            y += (radius + 70) * (y < canvas.height / 2 ? -1 : 1);
            // clamp
            y = Math.max(radius, Math.min(canvas.height - radius, y));
          }

          const angle = Math.random() * Math.PI * 2;
          obstacles.push({
            x,
            y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            radius,
            color: "#000000",
          });
        }
      }

      function update() {
        if (!gameRunning) return;

        // Move ball
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Move obstacles (chaotic movement)
        for (let ob of obstacles) {
          ob.x += ob.dx;
          ob.y += ob.dy;

          // Slightly change obstacle direction randomly for "chaotic" feel
          if (Math.random() < 0.01) {
            const angleChange = (Math.random() - 0.5) * 0.2;
            const speed = Math.sqrt(ob.dx * ob.dx + ob.dy * ob.dy);
            const currentAngle = Math.atan2(ob.dy, ob.dx);
            const newAngle = currentAngle + angleChange;
            ob.dx = Math.cos(newAngle) * speed;
            ob.dy = Math.sin(newAngle) * speed;
          }
        }

        // Wall collisions (top/bottom)
        if (ball.y <= 0 || ball.y + BALL_SIZE >= canvas.height) {
          ball.dy *= -1;
          playSound(226, 0.1);
        }

        // Obstacle wall collisions & ball collisions
        const ballCenterX = ball.x + BALL_SIZE / 2;
        const ballCenterY = ball.y + BALL_SIZE / 2;
        for (let ob of obstacles) {
          if (ob.x - ob.radius <= 0 || ob.x + ob.radius >= canvas.width) {
            ob.dx *= -1;
          }
          if (ob.y - ob.radius <= 0 || ob.y + ob.radius >= canvas.height) {
            ob.dy *= -1;
          }

          // Collision between ball and this obstacle
          const dx = ballCenterX - ob.x;
          const dy = ballCenterY - ob.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = BALL_SIZE / 2 + ob.radius;

          if (distance < minDistance) {
            // Normal vector
            const nx = dx / distance;
            const ny = dy / distance;

            // Dot product of velocity and normal
            const dotProduct = ball.dx * nx + ball.dy * ny;

            if (dotProduct < 0) {
              // Reflect ball velocity: v_new = v - 2 * (v . n) * n
              ball.dx = ball.dx - 2 * dotProduct * nx;
              ball.dy = ball.dy - 2 * dotProduct * ny;

              // Push ball out of obstacle to prevent sticking
              const overlap = minDistance - distance;
              ball.x += nx * overlap;
              ball.y += ny * overlap;

              playSound(600, 0.1);
            }
          }
        }

        // AI Movement (slightly weakened for human advantage)
        const aiCenter = ai.y + PADDLE_HEIGHT / 2;
        const aiSpeed = 3.2; // reduced so player has a better chance
        const aiError = Math.random() < 0.06; // small chance to hesitate
        const aiOffset = (Math.random() - 0.5) * 24; // aim offset to be less precise
        const aiTarget = ball.y + aiOffset;
        if (!aiError) {
          if (aiCenter < aiTarget - 12) {
            ai.y += aiSpeed;
          } else if (aiCenter > aiTarget + 12) {
            ai.y -= aiSpeed;
          }
        }

        // Keep paddles in bounds
        player.y = Math.max(
          0,
          Math.min(canvas.height - PADDLE_HEIGHT, player.y)
        );
        ai.y = Math.max(0, Math.min(canvas.height - PADDLE_HEIGHT, ai.y));

        // Paddle collisions
        // Player
        if (
          ball.dx < 0 &&
          ball.x <= player.x + PADDLE_WIDTH &&
          ball.y + BALL_SIZE >= player.y &&
          ball.y <= player.y + PADDLE_HEIGHT
        ) {
          ball.dx *= -1.1; // Speed up
          ball.x = player.x + PADDLE_WIDTH;
          playSound(459, 0.1);
          // Add some vertical influence based on where it hit the paddle
          const hitPos =
            (ball.y + BALL_SIZE / 2 - (player.y + PADDLE_HEIGHT / 2)) /
            (PADDLE_HEIGHT / 2);
          ball.dy += hitPos * 2;
        }

        // AI
        if (
          ball.dx > 0 &&
          ball.x + BALL_SIZE >= ai.x &&
          ball.y + BALL_SIZE >= ai.y &&
          ball.y <= ai.y + PADDLE_HEIGHT
        ) {
          ball.dx *= -1.05; // smaller speedup when AI hits
          ball.x = ai.x - BALL_SIZE;
          playSound(459, 0.1);
          const hitPos =
            (ball.y + BALL_SIZE / 2 - (ai.y + PADDLE_HEIGHT / 2)) /
            (PADDLE_HEIGHT / 2);
          ball.dy += hitPos * 2;
        }

        // Scoring
        if (ball.x < 0) {
          ai.score++;
          aiScoreEl.innerText = ai.score;
          playSound(150, 0.3);
          resetBall();
        } else if (ball.x > canvas.width) {
          player.score++;
          playerScoreEl.innerText = player.score;
          playSound(490, 0.3);

          if (player.score >= nextPlayerMilestone) {
            showMilestoneMessage(getNextMilestoneMessage());
            nextPlayerMilestone += 5;
          }

          resetBall();
        }
      }

      function draw() {
        // Clear
        ctx.fillStyle = "#8ca88b"; // Slightly darker inner screen
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw center line
        ctx.setLineDash([10, 10]);
        ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw paddles
        drawPaddle(player.x, player.y, player.color);
        drawPaddle(ai.x, ai.y, ai.color);

        // Draw obstacles
        for (let ob of obstacles) {
          ctx.beginPath();
          ctx.arc(ob.x, ob.y, ob.radius, 0, Math.PI * 2);
          ctx.fillStyle = ob.color;
          ctx.fill();
          ctx.closePath();

          // Retro detail for obstacle
          ctx.strokeStyle = "#8ca88b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(ob.x, ob.y, ob.radius - 5, 0, Math.PI * 2);
          ctx.stroke();
          ctx.closePath();
        }

        // Draw ball (Pixelated)
        ctx.fillStyle = ball.color;
        ctx.fillRect(ball.x, ball.y, BALL_SIZE, BALL_SIZE);
      }

      function drawPaddle(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, PADDLE_WIDTH, PADDLE_HEIGHT);

        // Retro detail: small gap in the middle or stripes
        ctx.fillStyle = "#8ca88b";
        for (let i = 4; i < PADDLE_HEIGHT; i += 8) {
          ctx.fillRect(x, y + i, PADDLE_WIDTH, 1);
        }
      }

      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      // Controls
      window.addEventListener("mousemove", (e) => {
        player.y = e.clientY - PADDLE_HEIGHT / 2;
      });

      window.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          player.y = touch.clientY - PADDLE_HEIGHT / 2;
        },
        { passive: false }
      );

      window.addEventListener("resize", resize);

      milestoneContinueBtn.addEventListener("click", hideMilestoneMessage);
      milestoneScreen.addEventListener("click", (e) => {
        if (e.target === milestoneScreen) hideMilestoneMessage();
      });
      window.addEventListener("keydown", (e) => {
        if (milestoneScreen.style.display !== "flex") return;
        if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
          e.preventDefault();
          hideMilestoneMessage();
        }
      });

      init();
      gameLoop();
    </script>
  </body>
</html>
